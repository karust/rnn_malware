import tempfile
import random
import os
import random
import string
import subprocess
import logging as log
import bson
import datetime
import psutil
import socket
from struct import unpack
#from keras.models import model_from_json

is32path = "is32bit.exe"
injector32path = "inject-x86.exe"
injector64path = "inject-x64.exe"
monitor32path = "monitor-x86.dll"
monitor64path = "monitor-x64.dll"
dllpath = ""
injector = ""
# log = logging.getLogger("analyzer")

def request_nn(calllist):
    data = ""
    for call in calllist:
        data += call + "*"
    data = data [:-2]

    HOST = '127.0.0.1'
    PORT = 8881

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    s.sendall(data.encode("utf-8"))
    data = s.recv(1024)

    s.close()

    return unpack("=f",data)[0]


class CommandPipeHandler(object):
    """Pipe Handler.
    This class handles the notifications received through the Pipe Server and
    decides what to do with them.
    """
    ignore_list = dict(pid=[])

    def __init__(self):
        self.tracked = {}

    """def _inject_process(self, process_id, thread_id, mode):
        proc = psutil.Process(process_id)
        filepath = proc.exe()
        if is32bit(filepath) == 32:
            injector = injector32path
            dllpath = monitor32path
        else:
            injector = injector64path
            dllpath = monitor64path
        args = [injector, 
                "--app", filepath,
                "--only-start",] 
        output = subprocess_checkoutput(args, None)
        pid, tid = map(int, output.split())
        print("Injected file pid is " + str(pid) + " and tid is " + str(tid))

        args = [
                injector,
                "--dll", dllpath,
                "--config", drop_config(),
                "--pid", str(pid),
                "--apc", 
                "--tid", str(tid),
                "--resume-thread"
            ]
        if subprocess_checkcall(args):
            log.error("Checkcall error")
            
        return "OK"""

    def _handle_debug(self, data):
        """Debug message from the monitor."""
        log.debug(data)

    def _handle_info(self, data):
        """Regular message from the monitor."""
        log.info(data)

    def _handle_warning(self, data):
        """Warning message from the monitor."""
        log.warning(data)

    def _handle_critical(self, data):
        """Critical message from the monitor."""
        log.critical(data)

    def _handle_loaded(self, data):
        """The monitor has loaded into a particular process."""
        if not data or data.count(",") != 1:
            log.warning("Received loaded command with incorrect parameters, "
                        "skipping it.")
            return

        pid, track = data.split(",")
        if not pid.isdigit() or not track.isdigit():
            log.warning("Received loaded command with incorrect parameters, "
                        "skipping it.")
            return

        log.debug("Loaded monitor into process with pid %s", pid)

    def _handle_getpids(self, data):
        """Return the process identifiers of the agent and its parent
        process."""
        return struct.pack("II", os.getpid(), os.getpid().get_parent_pid())

    def _handle_process(self, data):
        """Request for injection into a process."""
        # Parse the process identifier.
        if not data or not data.isdigit():
            log.warning("Received PROCESS command from monitor with an "
                        "incorrect argument.")
            return

        return self._inject_process(int(data), None, 0)

    def _handle_process2(self, data):
        """Request for injection into a process using APC."""
        # Parse the process and thread identifier.
        if not data or data.count(",") != 2:
            log.warning("Received PROCESS2 command from monitor with an "
                        "incorrect argument.")
            return

        pid, tid, mode = data.split(",")
        if not pid.isdigit() or not tid.isdigit() or not mode.isdigit():
            log.warning("Received PROCESS2 command from monitor with an "
                        "incorrect argument.")
            return

        return self._inject_process(int(pid), int(tid), int(mode))

    def _handle_kill(self, data):
        """A process is being killed."""
        if not data.isdigit():
            log.warning("Received KILL command with an incorrect argument.")
            return

        if self.analyzer.config.options.get("procmemdump"):
            dump_memory(int(data))

    def _handle_dumpmem(self, data):
        """Dump the memory of a process as it is right now."""
        if not data.isdigit():
            log.warning("Received DUMPMEM command with an incorrect argument.")
            return

        dump_memory(int(data))

    def _handle_dumpreqs(self, data):
        if not data.isdigit():
            log.warning("Received DUMPREQS command with an incorrect argument %r.", data)
            return

        pid = int(data)

        if pid not in self.tracked:
            log.warning("Received DUMPREQS command but there are no reqs for pid %d.", pid)
            return

        dumpreqs = self.tracked[pid].get("dumpreq", [])
        for addr, length in dumpreqs:
            log.debug("tracked dump req (%r, %r, %r)", pid, addr, length)

            if not addr or not length:
                continue

            Process(pid=pid).dump_memory_block(int(addr), int(length))

    def _handle_track(self, data):
        if not data.count(":") == 2:
            log.warning("Received TRACK command with an incorrect argument %r.", data)
            return

        pid, scope, params = data.split(":", 2)
        pid = int(pid)

        paramtuple = params.split(",")
        if pid not in self.tracked:
            self.tracked[pid] = {}
        if scope not in self.tracked[pid]:
            self.tracked[pid][scope] = []
        self.tracked[pid][scope].append(paramtuple)

    def dispatch(self, data):
        response = "NOPE"

        if not data or ":" not in data:
            log.critical("Unknown command received from the monitor: %r",
                         data.strip())
        else:
            # Backwards compatibility (old syntax is, e.g., "FILE_NEW:" vs the
            # new syntax, e.g., "1234:FILE_NEW:").
            if data[0].isupper():
                command, arguments = data.strip().split(":", 1)
                self.pid = None
            else:
                self.pid, command, arguments = data.strip().split(":", 2)

            fn = getattr(self, "_handle_%s" % command.lower(), None)
            if not fn:
                log.critical("Unknown command received from the monitor: %r",
                             data.strip())
            else:
                try:
                    response = fn(arguments)
                except:
                    log.exception(
                        "Pipe command handler exception occurred (command "
                        "%s args %r).", command, arguments
                    )

        return response

class LogPipeHandler(object):
    """Pipe Handler.
    This class handles the notifications received through the Pipe Server and
    decides what to do with them.
    """

    def __init__(self, filename, pid):
        self.filename = filename
        self.tracked = {}
        self.logname = ('Logs\\'+self.filename+"_"+str(datetime.datetime.now())+".log").replace(":","_").replace(" ","_")
        self.injectedproc = psutil.Process(pid)
        self.calllist = []



    def dispatch(self, data):
        response = "OK"
        try:
            #while injectedproc.
            decoded_data = bson.loads(data)
            #print(decoded_data)

            f = open(self.logname,"w+")
            f.write(str(decoded_data))
            f.close()

            if decoded_data['I']==174 and 'kernel32' in decoded_data:
                self.injectedproc.suspend()

                fname = str(decoded_data['args'][3])
                
                self.calllist.append(fname)
                #placeholder for NN 
                
                NNResponse = request_nn(self.calllist)
                print("API call recieved: " + fname +". Neural network response: "+str(NNResponse))
                if NNResponse > .5:
                    self.injectedproc.kill()
                else:
                    self.injectedproc.resume()
                
        except Exception as e:
            log.warning("BSON decode exception: "+str(e))
        return response



def random_string(minimum, maximum=None):
    if maximum is None:
        maximum = minimum

    count = random.randint(minimum, maximum)
    return "".join(random.choice(string.ascii_letters) for x in range(count))

pipe_name = "\\\\.\\pipe\\LOCAL\\"+random_string(16, 32)
logpipe_name = "\\\\.\\pipe\\LOCAL\\"+random_string(16, 32)
SHUTDOWN_MUTEX = "Global\\" + random_string(6, 10)

def subprocess_checkoutput(args, env=None):
    return subprocess.check_output(
        args, stdin=subprocess.PIPE, stderr=subprocess.PIPE, env=env,
    )

def subprocess_checkcall(args, env=None):
    subprocess.check_call(
        args, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
         env=env,
    )

def _encode_args(self, args):
    """Convert a list of arguments to a string that can be passed along
    on the command-line.
    @param args: list of arguments
    @return: the command-line equivalent
    """
    ret = []
    for line in args:
        if " " in line:
            ret.append('"%s"' % line)
        else:
            ret.append(line)
    return " ".join(ret)

def is32bit(filepath):
    bitsize = int(subprocess_checkoutput([is32path,"-f",filepath]))
    return bitsize

def inject(filepath):
    
    global dllpath
    global injector
    if is32bit(filepath) == 32:
        injector = injector32path
        dllpath = monitor32path
    else:
        injector = injector64path
        dllpath = monitor64path
    args = [injector, 
            "--app", filepath,
            "--only-start",] 
    output = subprocess_checkoutput(args, None)
    pid, tid = map(int, output.split())
    print("Injected file pid is " + str(pid) + " and tid is " + str(tid))

    args = [
            injector,
            "--dll", dllpath,
            "--config", drop_config(),
            "--pid", str(pid),
            "--apc", 
            "--tid", str(tid),
            "--resume-thread"
        ]
    if subprocess_checkcall(args):
        log.error("Checkcall error")
    
    return pid

def drop_config(track=True, mode=None, trigger=None):
        """Helper function to drop the configuration for a new process."""
        fd, config_path = tempfile.mkstemp()

        # The first time we come up with a random startup-time.
        first_process = True
        if first_process: #Process.first_process:
            # This adds 1 up to 30 times of 20 minutes to the startup
            # time of the process, therefore bypassing anti-vm checks
            # which check whether the VM has only been up for <10 minutes.
            startup_time = random.randint(1, 30) * 20 * 60 * 1000

        lines = {
            "pipe": pipe_name, #self.config.pipe,
            "logpipe": logpipe_name, #self.config.logpipe,
            "analyzer": os.getcwd(),
            "first-process": "1" if first_process else "0",
            "startup-time": startup_time,
            "shutdown-mutex": SHUTDOWN_MUTEX,
            "force-sleepskip": "1", #self.config.options.get("force-sleepskip", "0"),
            "track": "1" if track else "0",
            "mode": mode or "",
            "disguise": "0", #self.config.options.get("disguise", "0"),
            "pipe-pid": "1",
            "trigger": (trigger or "").encode("utf8"),
        }
        for key, value in lines.items():
            os.write(fd, ("%s=%s\n" % (key, value)).encode("utf-8"))

        os.close(fd)

        # Only change the first_process attribute for processes that we
        # "track", i.e., the lsass.exe injection doesn't count.
        #if track:
        #    Process.first_process = False

        return config_path

if __name__ == "__main__":
    from privileges import grant_privilege
    from pipe import PipeServer, PipeDispatcher, PipeForwarder
    #from ioctl import zer0m0n

    filename = "AutoClicker.exe"

    if not os.path.exists('Logs'): os.mkdir('Logs')

    grant_privilege("SeDebugPrivilege")
    grant_privilege("SeLoadDriverPrivilege")
    
    pid = inject(filename)
    
    print("Pipe name is "+pipe_name)
    print("LogPipe name is "+logpipe_name)
    command_pipe = PipeServer(
        PipeDispatcher, pipe_name, message=True,
        dispatcher=CommandPipeHandler())
    command_pipe.daemon = True
    command_pipe.start()

    destination = "127.0.0.1",8888
    logpipe_server = PipeServer(
        PipeDispatcher, logpipe_name, message=True,
        dispatcher=LogPipeHandler(filename, pid)
    )

    logpipe_server.daemon = True
    logpipe_server.start()

    logpipe_server.join()
    command_pipe.join()